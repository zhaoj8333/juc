package jmm.mem;

/**
    CPU读取缓存流程：
        （1）先读取寄存器的值，如果存在则直接读取
        （2）再读取L1，如果存在则先把cache行锁住，把数据读取出来，然后解锁
        （3）如果L1没有则读取L2，如果存在则先将L2中的cache行加锁，然后将数据拷贝到L1，再执行读L1的过程，最后解锁
        （4）如果L2没有则读取L3，同上先加锁，再往上层依次拷贝、加锁，读取到之后依次解锁
        （5）如果L3也没有数据则通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存到L3（如果没有就到L2），再从L3/2到L1，再从L1到CPU，之后解除总线锁定。

    MESI:
        +--------------+------------------------------------------------------+-----------------------------------------------------------------------------------------+
        | M：Modified  | cache line有效，但是被修改，与内存不一致，数据只存在于本cache | 缓存行必须时刻监听所有对该缓存行对应主存的操作，这种操作必须在该缓存行写回主存变成（S共享）状态时被延迟执行 |
        +--------------+------------------------------------------------------+-----------------------------------------------------------------------------------------+
        | E：Exclusive | cache line有效，数据与内存一致，只存在于本cache            | 缓存行必须监听其他缓存读主存相对于该缓存的操作，一旦有，该缓存行变成S共享 状态                         |
        +--------------+------------------------------------------------------+-----------------------------------------------------------------------------------------+
        | S：Shared    | cache line有效，数据和内存一致，存在于很多cache中           | 缓存行必须监听其他缓存行，无效或者独享的请求，并将改缓存行设置为I无效 状态                           |
        +--------------+------------------------------------------------------+-----------------------------------------------------------------------------------------+
        | I：Invalid   | cache line无效                                        |                                                                                         |
        +--------------+------------------------------------------------------+-----------------------------------------------------------------------------------------+

    Java线程与系统内核关系：
        JDK1.2之前，基于绿色线程实现，之后，基于OS原生线程模型实现
        绿色线程：基于最初的java线程库，由运行库或VM调度，而不是底层OS调度，发生于用户空间，绿色现场执行阻塞系统调用，当前进程所有线程都会被阻塞，所以最好使用异步I/O操作
        原生线程：可以自动将工作分配给多个处理器，绿色现场不能做到，linux上，绿色现场在激活和同步上优于原生线程，但是原生线程在I/O操作和上下文切换优于绿色线程，
        虚拟机规范没有限定java线程需要哪种线程模型来实现

        java线程与内核线程是一一对应的关系：
            线程调度交给OS内核，jvm保留了一些影响线程调度的因素，在linux下，只要一个Thread.run就会调用一个fork产生一个线程。
            windows和linux上，java线程的实现是直接由OS系统内核支持的--由内核调度，在程序面上使用内核线程，必然在操作系统上多次来回切换用户态及内核态，因为是一对一的线程模型，LWP的支持数是有限的。

            对于一个大型程序，可开辟的线程数量至少等于机器的cpu数量，

        线程开辟数量：
            计算密集型：最小线程数就是所需要的线程数，
            IO密集型： 可以开辟更多线程数
            如果线程有50%的时间被阻塞，线程数量应该是内核数量的2倍，
            线程数量=内核数量 / （1 - 阻塞率）

    JMM： java内存模型
        用于屏蔽各种硬件和OS差异，以实现java在不同平台上的一致性的内存访问结果

        JMM定义了线程和主内存之间的抽象关系：
            线程共享变量存储在主内存，线程有自己的私有本地内存，本地内存存储了该线程读写共享变量的副本。
            本地内存并不真实存在，涵盖了缓存，写缓冲，寄存器和硬件和编译器优化。

            JMM与java内存结构并不是同一层次的内存划分，两者基本没有关系。勉强对应的话，主内存主要对应于java堆中的对象实例数据部分，工作内存主要对应于虚拟机栈的部分区域。
                主内存：主要存储 所有线程创建的实例对象，包括共享类信息，常量，静态变量
                工作内存：方法中的所有本地变量，主内存变量副本，
                    线程只能访问本地工作内存，对其他线程不可见，因此是线程的私有数据。
                    就算是两个线程执行同一段代码，在各自的工作内存中创建的变量也是自己的本地变量，包括字节码行号指示器，native方法信息，虚拟机栈，本地方法栈
                    工作内存数据不存在线程安全问题

                线程之间无法呼吸访问工作内存，因此工作内存的数据不存在线程安全问题。
                线程之间变量的传递均需要通过主内存来完成。

        工作内存与主内存的同步：
            lock（锁定）：作用于主内存变量，将变量标记为独占状态
            unlock（解锁）：作用于主内存，释放该变量，释放后才能被其他线程锁定

            read（读取）：作用于主内存，将主内存变量复制到工作内存，以便load
            load（载入）：作用于工作内存，把read操作从主内存中得到的变量放入工作内存的变量副本
            // read,load：把变量从主内存复制到工作内存

            use（使用）：作用于工作内存，把工作内存变量传递给执行引擎
            assign（赋值）：作用于工作内存，把从执行引擎接收到的值赋给工作内存变量

            store（存储）：作用于工作内存，把工作内存变量值传到主内存，以便write
            write（写入）：作用于工作内存，把store操作的变量传到主内存变量
            // store,write：把变量从工作内存同步到主存

            JMM要求read,load和store,write按序执行，但没有规定是连续执行

        同步规则：
            不允许一个线程没有发生任何assign操作就把数据从工作内存同步到主内存
            新变量只能在主内存诞生，不允许在工作内存中直接使用一个未初始化的(load或assign)的变量，即：在对变量use和store之前，必须assign和load
            一个变量同一时刻只允许一个线程对其进行lock，但可能被同一线程lock多次，多次lock必须有同样次数的unlock，变量才会被解锁（lock与unlock成对）
            如果对变量执行lock，将清空工作内存此变量的值，执行引擎use该变量之前，需要重新load或assign操作初始化变量的值
            如果一个变量事先未被lock，则不允许unlock，也不允许unlock其他线程lock的变量
            对变量unlock之前，必须把变量store和write

        JMM解决了多线程并发问题：
            原子性：
                CPU上下文切换，导致多线程内的多个操作并不是原子执行
                jvm自身提供的基本数据类型的读写是原子操作的，可以通过synchronized和lock实现原子性，因为保证了同一时刻只有一个线程访问
            可见性：
                可见性问题由工作内存与主内存同步延迟导致，指令重排也会造成可见性问题
                volatile关键字保障可见性，volatile变量保障被修改的值立即被其他线程看到
                synchronized和Lock也可以保证可见性，因为保证了只有一个线程可以访问共享资源，并将在锁释放之前刷新主存
                (Lock：AQS的state是volatile的，volatile为了保证可见性加入了lock指令，lock指令强制把缓存[工作内存]写回内存[主内存])，并失效其他线程的缓存行(MESI),lock会把工作内存中的所有变更都写回主存)
            有序性：
                多线程下会出现指令重排序现象
                volatile可以保证有序性，synchronized和Lock可以保证是有一个线程执行同步代码，相当于让线程顺序执行同步代码，自然保证了有序性

 */